# ë ˆë””ìŠ¤ë¡œ ì¸ê¸°ìƒí’ˆ ì¡°íšŒ ê°œë°œí•˜ê¸°

---

## ğŸ¯ ëª©í‘œ

1. **ì‹¤ì‹œê°„ ë­í‚¹**
  - **ìš”êµ¬ì‚¬í•­**
    - ì£¼ë¬¸ì´ ì™„ë£Œë˜ë©´ ë¹„ë™ê¸° ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œ  
      `productId`ì™€ `ìˆ˜ëŸ‰`ì„ Redis Sorted Setì— ë°˜ì˜
    - ì¸ê¸°ìƒí’ˆ ì¡°íšŒ ì‹œ í•´ë‹¹ Sorted Setì„ ë°”ë¡œ ì½ì–´ì˜´
  - **TTL**: 24ì‹œê°„ (24h)
  - **í‚¤ ì „ëµ**

    | êµ¬ë¶„        | í‚¤                   | ì„¤ëª…                         |
    | ----------- | -------------------- | ---------------------------- |
    | ì‹¤ì‹œê°„ ë­í‚¹ | `ranking:live`       | ë§ˆì§€ë§‰ 24ì‹œê°„ ëˆ„ì  ì§‘ê³„     |

---

2. **ì¼ê°„ ì¸ê¸°ìƒí’ˆ ì¡°íšŒ**
  - **ìš”êµ¬ì‚¬í•­**
    - 00:00 ~ 23:50ê¹Œì§€ì˜ ì£¼ë¬¸ í†µê³„ë¥¼ ì§‘ê³„
    - ë§¤ì¼ 23:50ì— ë°°ì¹˜ë¡œ ìºì‹œì— ì ì¬ (pre-warm)
    - í´ë¼ì´ì–¸íŠ¸ëŠ” ìºì‹œë§Œ ì¡°íšŒí•˜ë„ë¡ ìœ ë„
  - **TTL**: 25ì‹œê°„
  - **í‚¤ ì „ëµ**
    ```text
    ranking:daily:{YYYYMMDD}
    // ì˜ˆ) ranking:daily:20250514
    ```

  - **ìŠ¤ì¼€ì¤„ ì˜ˆì‹œ**
    ```java
    @Scheduled(cron = "0 50 23 * * *", zone = "Asia/Seoul")
    public void warmDailyRanking() {
        // ì¼ê°„ ì§‘ê³„ ë¡œì§ â†’ Redisì— set
    }
    ```

---

3. **ì£¼ê°„ ì¸ê¸°ìƒí’ˆ ì¡°íšŒ**
  - **ìš”êµ¬ì‚¬í•­**
    - ìµœê·¼ 7ì¼ê°„(ì§‘ê³„ì¼ í¬í•¨)ì˜ ì£¼ë¬¸ í†µê³„ë¥¼ ì§‘ê³„
    - ë§¤ì¼ 23:50ì— ë°°ì¹˜ë¡œ ìºì‹œì— ì ì¬
    - ISO ì£¼ ë‹¨ìœ„(â€˜2025-20ì£¼ì°¨â€™ ë“±)ë¡œ êµ¬ë¶„
  - **TTL**: 25ì‹œ
  - **í‚¤ ì „ëµ**
    ```text
    ranking:weekly:{YYYY}-{WW}
    // ì˜ˆ) ranking:weekly:2025-20
    ```

  - **ìŠ¤ì¼€ì¤„ ì˜ˆì‹œ**
    ```java
    @Scheduled(cron = "0 50 23 * * *", zone = "Asia/Seoul")
    public void warmWeeklyRanking() {
        // ì£¼ê°„ ì§‘ê³„ ë¡œì§ â†’ Redisì— set
    }
    ```

---

## ğŸ”¥ Cache Stampede ë°©ì§€

- **ì‚¬ì „ ì˜ˆì—´(Pre-warming)**
  - í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ì‹œ DB ì¡°íšŒë¥¼ ë°©ì§€
  - ë°°ì¹˜ íƒ€ì´ë°ì— ë§ì¶° ìºì‹œ ê°±ì‹ 
- **TTL ì „ëµ**
  - ì¼ê°„/ì£¼ê°„ì€ ì§‘ê³„ ì£¼ê¸° + 1ì¼ ì—¬ìœ 
  - ì‹¤ì‹œê°„ ë­í‚¹ì€ 24ì‹œê°„ ëˆ„ì 

---

## ğŸ“ˆ ìš”ì•½

| êµ¬ë¶„            | ì§‘ê³„ ì£¼ê¸°              | í‚¤ ì˜ˆì‹œ                         | ë°°ì¹˜ ìŠ¤ì¼€ì¤„               | TTL    |
| --------------- | ---------------------- | ------------------------------ | ------------------------- | ------ |
| **ì‹¤ì‹œê°„ ë­í‚¹** | ì‹¤ì‹œê°„(ì´ë²¤íŠ¸ ë°œìƒ ì‹œ) | `ranking:live`                 | â€”                         | 24h    |
| **ì¼ê°„ ë­í‚¹**   | 00:00~23:50            | `ranking:daily:20250514`       | ë§¤ì¼ 23:50 (`cron`)       | 25h    |
| **ì£¼ê°„ ë­í‚¹**   | ìµœê·¼ 7ì¼                | `ranking:weekly:2025-20`       | ë§¤ì¼ 23:50 (`cron`)       | 25h    |


```java
// ì˜ˆ: ë§¤ì¼ 23ì‹œ 50ë¶„ì— ì‹¤í–‰
@Scheduled(cron = "0 50 23 * * *", zone = "Asia/Seoul")
public void warmRankingCaches() { â€¦ }
```
---

# ì½”ë“œêµ¬í˜„
## 1. ì‹¤ì‹œê°„ ë­í‚¹ êµ¬í˜„í•˜ê¸°
OrderFacadeì—ì„œ ì£¼ë¬¸ì„ ì„±ê³µí•˜ë©´ ì´ë²¤íŠ¸ë¥¼ ë°œìƒí•˜ì—¬ ì»¤ë°‹ í›„ì— ë ˆë””ìŠ¤ì— ìƒí’ˆì— ëŒ€í•œ íŒë§¤ê°œìˆ˜ë¥¼ ì €ì¥í• ìˆ˜ ìˆë„ë¡ ì²˜ë¦¬í•œë‹¤. publish ë¥¼ í˜¸ì¶œí•˜ë©´ TransactionalEventListenerê°€ ì»¤ë°‹ì´í›„ì— ì‹¤í–‰ëœë‹¤.
```java
	@Transactional
	public OrderResult.Order order(OrderCriteria.CreateOrder criteria) {
		// ì¬ê³  ì¡°íšŒ
		// ì¿ í° ì‚¬ìš©
		// ì£¼ë¬¸ ìƒì„±
		// ì£¼ë¬¸
	    // í¬ì¸íŠ¸ ì°¨ê°
        // ê²°ì¬ì™„ë£Œ

		publisher.publishEvent(new OrderCompletedEvent(criteria.getOrderItems()));
		return result;
	}
```

ì´ë²¤íŠ¸ëŠ” `@TransactionalEventListener`ë¡œ ë°›ì•„ ì‹¤ì‹œê°„ ì£¼ë¬¸ë‚´ì—­ì— ëŒ€í•´ ë ˆë””ìŠ¤ì— ì €ì¥í•  ìˆ˜ ìˆë‹¤.
```java
public class RankingUpdater {

	private final RedisRepository redisRepository;

	@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
	public void handleOrderCompleted(OrderCompletedEvent event) {
		String LIVE_RANK_KEY = "ranking:live";

		for (OrderCriteria.OrderItem item : event.getItems()) {
			redisRepository.incrSortedSet(LIVE_RANK_KEY, String.valueOf(item.getProductId()), item.getQuantity(), Duration.ofDays(1));
		}
	}
}
```
## 2. ì¼ê°„/ì£¼ê°„ ì£¼ë¬¸ë‚´ì—­ ì§‘ê³„í•˜ì—¬ ì¸ê¸°ìƒí’ˆ ì ì¬í•˜ê¸°
```java

public class BestItemScheduler {

	private static final DateTimeFormatter DAILY_FORMAT = DateTimeFormatter.BASIC_ISO_DATE;
	private static final DateTimeFormatter WEEKLY_FORMAT = DateTimeFormatter.ofPattern("YYYY-ww");
	public static final String DAILY_KEY_PREFIX = "ranking:daily:";
	public static final String WEEK_KEY_PREFIX = "ranking:weekly:";

	// ì¼ê°„ ì¸ê¸°ë­í‚¹
	@Scheduled(cron = "0 50 23 * * *")
	@Transactional
	public void warmDailyRanking() {
		List<OrderItem> OrderOneDayStats = orderService.getOrderBeforeHour(24);

		Map<Long, Long> salesOneDayMap = getSalesMap(OrderOneDayStats);

		salesOneDayMap.forEach((productId, salesQuantity) -> {
			Product product = productService.findById(productId);
			String dailyKey = DAILY_KEY_PREFIX + LocalDate.now().format(DAILY_FORMAT);
			redisRepository.addSortedSetWithTTL(dailyKey, String.valueOf(product.getId()), salesQuantity, Duration.ofHours(25));
		});
	}

	// ì£¼ê°„ ì¸ê¸°ë­í‚¹
	@Scheduled(cron = "0 50 23 * * *")
	@Transactional
	public void warmWeeklyRanking() {
		List<OrderItem> orderOneWeekStats = orderService.getOrderBeforeDay(7);

		Map<Long, Long> salesOneWeekMap = getSalesMap(orderOneWeekStats);

		salesOneWeekMap.forEach((productId, salesQuantity) -> {
			Product product = productService.findById(productId);
			String weekKey = WEEK_KEY_PREFIX + LocalDate.now().format(WEEKLY_FORMAT);
			redisRepository.addSortedSetWithTTL(weekKey, String.valueOf(product.getId()), salesQuantity, Duration.ofHours(25));
		});
	}


	private static Map<Long, Long> getSalesMap(List<OrderItem> OrderOneDayStats) {
		return OrderOneDayStats.stream().collect(Collectors.groupingBy(
			OrderItem::getProductId,
			Collectors.summingLong(OrderItem::getQuantity)
		));
	}
}
```

## 3. ì‹¤ì‹œê°„/ì¼ê°„/ì£¼ê°„ ì¸ê¸°ìƒí’ˆ ë ˆë””ìŠ¤ë¡œ ì¡°íšŒí•˜ê¸°
```java
@Transactional
public Set<Object> getTop10LiveRank() {
    log.info("ì‹¤ì‹œê°„ ì¸ê¸°ìƒí’ˆì¡°íšŒ");
    String LIVE_RANK_KEY = "ranking:live";
    return redisRepository.getSoretedSetReverseRange(LIVE_RANK_KEY,10);
}

@Transactional
public Set<Object> getTop10DailyRank() {
    log.info("ì¼ê°„ ì¸ê¸°ìƒí’ˆ ì¡°íšŒ");
    String DAILY_KEY_PREFIX = "ranking:daily:";
    String dailyKey = DAILY_KEY_PREFIX + LocalDate.now().format(DAILY_FORMAT);
    return redisRepository.getSoretedSetReverseRange(dailyKey,10);
}

@Transactional
public Set<Object> getTop10WeeklyRank() {
    log.info("ì£¼ê°„ ì¸ê¸°ìƒí’ˆ ì¡°íšŒ");
    String WEEK_KEY_PREFIX = "ranking:weekly:";
    String weekKey = WEEK_KEY_PREFIX + LocalDate.now().format(WEEKLY_FORMAT);
    return  redisRepository.getSoretedSetReverseRange(weekKey,10);
}
```

---
# í…ŒìŠ¤íŠ¸
## 1. ì‹¤ì‹œê°„ ë­í‚¹
```java
@Test
@DisplayName("[ì„±ê³µ] ì£¼ë¬¸ìš”ì²­ì‹œ ì‹¤ì‹œê°„ ì¸ê¸°ìƒí’ˆ ì§‘ê³„ë¥¼ ìœ„í•´ ë°ì´í„°ê°€ ì €ì¥ëœë‹¤.")
void concurrency_order_success() {
    // given
    // ì‚¬ìš©ì ìƒì„±
    // í¬ì¸íŠ¸ ìƒì„±
    // ìƒí’ˆ ìƒì„±
    Product product1 = Product.create("ìŠ¤í…Œì´í¬", 10_000L);
    Product product2 = Product.create("ìˆ˜ë°•", 10_000L);
    productRepository.save(product1);
    productRepository.save(product2);
    
    // ìƒí’ˆ ì¬ê³  ìƒì„±
    // product1ì„ 10ê°œ ì£¼ë¬¸
    OrderCriteria.OrderItem orderItem1 = OrderCriteria.OrderItem.of(product1.getId(), 10);
    
    // product2ì„ 20ê°œ ì£¼ë¬¸
    OrderCriteria.OrderItem orderItem2 = OrderCriteria.OrderItem.of(product2.getId(), 20);
    
    // ì£¼ë¬¸ì •ë³´ ìƒì„±
    OrderCriteria.CreateOrder orderCriteria = OrderCriteria.CreateOrder.of(user.getId(),null, List.of(orderItem1,orderItem2));
    
    // when
    OrderResult.Order ordered = orderFacade.order(orderCriteria);
    
    // then
    String LIVE_RANK_KEY = "ranking:live";
    Set<Object> result = redisRepository.reverseRange(LIVE_RANK_KEY, 0L, 10L);
    
    assertThat(result).extracting(o -> ((String)o)).containsExactly(String.valueOf(product2.getId()),String.valueOf(product1.getId()));
    }
```

#### í…ŒìŠ¤íŠ¸ ê²°ê³¼ 
![img.png](img.png)

#### ë ˆë””ìŠ¤ì—ì„œ ë°ì´í„° í™•ì¸
![img_1.png](img_1.png)

## 2. ì¼ê°„ ë­í‚¹
```java
@Test
@DisplayName("ì¼ê°„ ì¸ê¸°ìƒí’ˆì„ ë ˆë””ìŠ¤ ìºì‹œì—ì„œ ì¡°íšŒí•œë‹¤.")
void get_daily_rank_item() {

    // given
    // 1ë²ˆ ìƒí’ˆ 10ê°œ, 2ë²ˆìƒí’ˆ 20ê°œ....9ë²ˆìƒí’ˆ 90ê°œ..
    String dailyKey = DAILY_KEY_PREFIX + LocalDate.now().format(DAILY_FORMAT);
    IntStream.range(1,10).forEach((i) -> {
        redisRepository.addSortedSetWithTTL(dailyKey,String.valueOf(i),i*10, Duration.ofHours(25));
    });

    // when
    bestItemScheduler.warmDailyRanking();
    
    // then
    Set<Object> result = bestItemService.getTop10DailyRank();
    assertThat(result).extracting(o -> ((String)o)).containsExactly("9", "8", "7", "6", "5", "4", "3", "2", "1");
}
```
#### í…ŒìŠ¤íŠ¸ ê²°ê³¼
![img_2.png](img_2.png)
![img_3.png](img_3.png)


## 3. ì£¼ê°„ ë­í‚¹
ì¼ê°„ ë­í‚¹ê³¼ í…ŒìŠ¤íŠ¸ ë°©ì‹ì€ ë™ì¼

#### í…ŒìŠ¤íŠ¸ ê²°ê³¼
![img_4.png](img_4.png)